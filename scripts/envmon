#!/usr/bin/env python
#
# envmon.py -- Flexible Gen2 environment monitor.
#
# E. Jeschke
#
"""
Usage:
    envmon.py --plugins=X,Y,Z
"""
# stdlib imports
import sys, os
import threading
import queue as Queue
from argparse import ArgumentParser

import statmon.version
moduleHome = os.path.split(sys.modules['statmon.version'].__file__)[0]
sys.path.insert(0, moduleHome)
pluginHome = os.path.join(moduleHome, 'plugins')
sys.path.insert(0, pluginHome)

from g2base import Task
from g2base.remoteObjects import remoteObjects as ro
from g2cam.status.stream import StatusStream

from ginga import toolkit
toolkit.use('qt5')
from ginga.gw import Widgets
from ginga.misc import ModuleManager, Settings, log

# Local application imports
from statmon.Model import StatusModel
from statmon.View import Viewer
from statmon.Control import Controller

defaultServiceName = 'envmon'
version = "20211207.0"

default_layout = ['seq', {},
                  ['vbox', dict(name='toplvl', width=1440, height=1074),
                   ['hbox', dict(name='menubox', stretch=0)],
                   ['vbox', dict(stretch=1),
                     ['hpanel', dict(stretch=1),
                      ['scrollable', dict(width=350, stretch=1),
                       ['vbox', dict(height=1000, stretch=1),
                        ['ws', dict(name='left1', height=25, stretch=0,
                                    show_tabs=False), ],
                        ['ws', dict(name='left', width=350, show_tabs=False), ],
                        ]],
                      ['scrollable', dict(width=350, stretch=1),
                       ['vbox', dict(height=1000, stretch=1),
                        ['ws', dict(name='middle', width=350, show_tabs=False), ],
                        ]],
                      ['scrollable', dict(width=350, stretch=1),
                       ['vbox', dict(height=1000, spacing=4, stretch=1),
                        ['ws', dict(name='right', show_tabs=False), ],
                        ]],
                     ]
                    ],
                   ['hbox', dict(name='statusbox', stretch=0)],
                   ]
                  ]

plugins = [
    # pluginName, moduleName, className, workspaceName, tabName
    ('envmon5', 'EnvMon5', 'EnvMon5', 'left', ''),
    ('precip', 'PrecipPlugin', 'PrecipPlugin', 'left1', ''),
    ('envmon4', 'EnvMon4', 'EnvMon4', 'middle', ''),
    ('envmon3', 'EnvMon3', 'EnvMon3', 'right', ''),
    ('debug', 'Debug', 'Debug', 'right', "Debug"),
    ]

class EnvMon(Controller, Viewer):

    def __init__(self, logger, threadPool, module_manager, settings,
                 ev_quit, model):

        Viewer.__init__(self, logger, ev_quit)
        Controller.__init__(self, logger, threadPool, module_manager,
                            settings, ev_quit, model)

    def add_menus(self):
        menubar = Widgets.Menubar()
        self.w.menubox.add_widget(menubar, stretch=0)

        # create a File pulldown menu, and add it to the menu bar
        filemenu = menubar.add_name("File")

        filemenu.add_separator()

        item = filemenu.add_name("Quit")
        item.add_callback('activated', self.quit)

        # create a Option pulldown menu, and add it to the menu bar
        ## optionmenu = menubar.add_name("Option")

    def add_statusbar(self):
        self.w.status = Widgets.StatusBar()
        self.w.statusbox.add_widget(self.w.status, stretch=1)


def main(options, args):

    # Create top level logger.
    svcname = options.svcname
    logger = log.get_logger(svcname, options=options)

    # Initialize remote objects subsystem.
    try:
        ro.init([options.gen2host])

    except ro.remoteObjectError as e:
        logger.error("Error initializing remote objects subsystem: %s" % \
                     str(e))
        sys.exit(1)

    ev_quit = threading.Event()

    threadPool = Task.ThreadPool(logger=logger, ev_quit=ev_quit,
                                 numthreads=options.numthreads)

    # Get settings folder
    if 'CONFHOME' in os.environ:
        basedir = os.path.join(os.environ['CONFHOME'], svcname)
    else:
        basedir = os.path.join(os.environ['HOME'], '.' + svcname)
    if not os.path.exists(basedir):
        os.mkdir(basedir)
    prefs = Settings.Preferences(basefolder=basedir, logger=logger)

    mm = ModuleManager.ModuleManager(logger)

    # Add any custom modules
    if options.modules:
        modules = options.modules.split(',')
        for mdlname in modules:
            #self.mm.loadModule(name, pfx=pluginconfpfx)
            self.mm.loadModule(name)

    model = StatusModel(logger)

    # Start up the control/display engine
    envmon = EnvMon(logger, threadPool, mm, prefs, ev_quit, model)

    # Build desired layout
    envmon.build_toplevel(layout=default_layout)
    envmon.w.root.set_title("EnvMon")
    for w in envmon.ds.toplevels:
        w.show()

    for pluginName, moduleName, className, wsName, tabName in plugins:
        envmon.load_plugin(pluginName, moduleName, className,
                            wsName, tabName)

    envmon.update_pending()

    # Did user specify geometry
    if options.geometry:
        envmon.set_geometry(options.geometry)

    server_started = False

    # Create receiver and start it
    try:
        settings = prefs.create_category('status')
        st_stream = None
        try:
            settings.load()

            # set up the status stream interface
            st_stream = StatusStream(host=settings.get('stream_host'),
                                     username=settings.get('stream_user'),
                                     password=settings.get('stream_pass'),
                                     logger=logger)
            st_stream.connect()

        except Exception as e:
            logger.error("Error setting up status stream: {}".format(e),
                         exc_info=True)

        threadPool.startall(wait=True)

        # intermediary queue
        status_q = Queue.Queue()

        # stream producer puts updates on the queue
        task1 = Task.FuncTask2(st_stream.subscribe_loop, ev_quit, status_q)
        task1.init_and_start(envmon)

        # stream consumer takes them and updates the status cache
        task2 = Task.FuncTask2(model.consume_stream, ev_quit, status_q)
        task2.init_and_start(envmon)

        try:
            # Main loop to handle GUI events
            envmon.mainloop(timeout=0.001)

        except KeyboardInterrupt:
            logger.error("Received keyboard interrupt!")

    finally:
        logger.info("Shutting down...")

        envmon.close_all_plugins()
        envmon.stop()

        threadPool.stopall(wait=True)

    sys.exit(0)


if __name__ == "__main__":

    # Parse command line options
    argprs = ArgumentParser(description="Gen2 Status Monitor")

    argprs.add_argument('-f', "--config", dest="configfile", default=None,
                        help="Specify configuration file")
    argprs.add_argument("--display", dest="display", metavar="HOST:N",
                        help="Use X display on HOST:N")
    argprs.add_argument("-g", "--geometry", dest="geometry",
                        metavar="GEOM", default="+20+100",
                    help="X geometry for initial size and placement")
    argprs.add_argument("--gen2host", dest="gen2host",
                        metavar="HOST", default="localhost",
                        help="Connect to Gen2 HOST")
    argprs.add_argument("--modules", dest="modules", metavar="NAMES",
                        help="Specify additional modules to load")
    argprs.add_argument("--numthreads", dest="numthreads", type=int,
                        default=10,
                        help="Start NUM threads in thread pool", metavar="NUM")
    argprs.add_argument("--plugins", dest="plugins", metavar="NAMES",
                        help="Specify additional plugins to load")
    argprs.add_argument("--svcname", dest="svcname", metavar="NAME",
                        default=defaultServiceName,
                        help="Register using NAME as service name")
    log.addlogopts(argprs)

    (options, args) = argprs.parse_known_args(sys.argv[1:])

    if options.display:
        os.environ['DISPLAY'] = options.display

    main(options, args)
